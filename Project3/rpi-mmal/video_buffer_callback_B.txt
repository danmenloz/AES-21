video_buffer_callback() /home/pi/Documents/AES-21/Project3/rpi-mmal/build/istool1
Event: cpu-clock:uhH

Percent        
               
               
        3    Disassembly of section .text:
               
        5    00013d10 <video_buffer_callback>:
        6    video_buffer_callback():
        238    *rcy = cy;
               
        240    return matches;
        241  }          
               
        243  void video_buffer_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer) {
  0.03         strd   r4, [sp, #-36]! ; 0xffffffdc
               mov    r5, r1  
        257    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t1);
               
        259    MMAL_BUFFER_HEADER_T *new_buffer;
        260    MMAL_POOL_T *pool = (MMAL_POOL_T *) port->userdata;
               
        262    loop++;  
               movw   r4, #33016      ; 0x80f8
               movt   r4, #2  
        238  void video_buffer_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer) {
  0.03         strd   r6, [sp, #8]
               mov    r7, r0  
               strd   r8, [sp, #16]
               strd   sl, [sp, #24]
               str    lr, [sp, #32]
               vpush  {d8-d14}
               sub    sp, sp, #76     ; 0x4c
               strd   r0, [sp, #28]
        251    clock_gettime(CLOCK_MONOTONIC, &tcf);
               add    r1, sp, #64     ; 0x40
               mov    r0, #1  
             → bl     clock_gettime@plt
        252    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t1);
               add    r1, sp, #48     ; 0x30
               mov    r0, #2  
             → bl     clock_gettime@plt
        257    loop++;  
               ldr    r1, [r4]
               mov    r0, r4  
        269    unsigned char * Y = buffer->data;
        270    unsigned char * U = &(buffer->data[Y_array_size]);
        271    unsigned char * V = &(buffer->data[Y_array_size + UV_array_size]);
               
        273    // initialize YUV_IMAGE_T data structures describing images
        274    YUV_Image_Init(&img, (unsigned char *) (buffer->data), w, h); // original image
               mov    r3, #720        ; 0x2d0
               mov    r2, #1280       ; 0x500
        264    unsigned char * Y = buffer->data;
               ldr    r6, [r5, #12]
        275    YUV_Image_Init(&img2, img2_bitplanes, w, h); // extra space for modified image
               
        277    // update target color
        278    YUV_T center_color;
        279    Get_Pixel_yuv(&img, img.half_w, img.half_h, &center_color);
        280    if (show_data > 2)
               movw   r5, #32928      ; 0x80a0
               movt   r5, #2  
        255    MMAL_POOL_T *pool = (MMAL_POOL_T *) port->userdata;
               ldr    ip, [r7, #56]   ; 0x38
        257    loop++;  
               add    r1, r1, #1
        275    if (show_data > 2)
               str    r5, [sp, #24]
        257    loop++;  
               str    r1, [r0], #4
        269    YUV_Image_Init(&img, (unsigned char *) (buffer->data), w, h); // original image
               mov    r1, r6  
        255    MMAL_POOL_T *pool = (MMAL_POOL_T *) port->userdata;
               str    ip, [sp, #36]   ; 0x24
        269    YUV_Image_Init(&img, (unsigned char *) (buffer->data), w, h); // original image
             → bl     YUV_Image_Init
        270    YUV_Image_Init(&img2, img2_bitplanes, w, h); // extra space for modified image
               add    r0, r4, #32
               mov    r3, #720        ; 0x2d0
               mov    r2, #1280       ; 0x500
               movw   r1, #33128      ; 0x8168
               movt   r1, #2  
             → bl     YUV_Image_Init
        274    Get_Pixel_yuv(&img, img.half_w, img.half_h, &center_color);
               add    r3, sp, #44     ; 0x2c
               add    r0, r4, #4
               ldr    r1, [r4, #12]
               ldr    r2, [r4, #16]
             → bl     Get_Pixel_yuv
        275    if (show_data > 2)
               ldr    r3, [r5]
               cmp    r3, #2  
             ↓ bgt    664     
        277      printf("\nCenter pixel: (%d, %d, %d)\n", center_color.y, center_color.u, center_color.v);
        278    if (update_target_color) {
         b8:   movw   r2, #33000      ; 0x80e8
               movt   r2, #2  
               ldr    r3, [r2]
        278      if (debug_rectangle)
               movw   r5, #32916      ; 0x8094
               movt   r5, #2  
        277    if (update_target_color) {
               cmp    r3, #0  
             ↓ beq    118     
        278      if (debug_rectangle)
               ldr    r3, [r5]
               cmp    r3, #0  
             ↓ bne    634     
        281        target = red;
        282      else   
        283        target = center_color;
               ldrb   r0, [sp, #46]   ; 0x2e
               movw   r1, #32964      ; 0x80c4
               movt   r1, #2  
               ldrh   r3, [sp, #44]   ; 0x2c
               strh   r3, [r1]
               strb   r0, [r1, #2]
        282      update_target_color = 0;
         f8:   mov    ip, #0  
        283      printf("\nUpdated target color: (%d, %d, %d)\n", target.y, target.u, target.v);
               movw   r0, #31044      ; 0x7944
               movt   r0, #1  
               ldrb   r3, [r1, #2]
        282      update_target_color = 0;
               str    ip, [r2]
        283      printf("\nUpdated target color: (%d, %d, %d)\n", target.y, target.u, target.v);
               ldrb   r2, [r1, #1]
               ldrb   r1, [r1]
             → bl     printf@plt
        287    }        
               
        289    // invert Y channel
        290    if (invert) { // Y: luminance.
        118:   movw   r3, #33008      ; 0x80f0
               movt   r3, #2  
               ldr    r3, [r3]
               cmp    r3, #0  
             ↓ beq    5d8     
               add    r3, r6, #921600 ; 0xe1000
        291      // Invert Luminance, one word at a time
        292      unsigned int * Y32 = (unsigned int * ) Y;
        293      do {   
        294        *Y32 ^= 0xffffffff;
        130:   vld1.32 {d16-d17}, [r6]
               vmvn   q8, q8  
               vst1.32 {d16-d17}, [r6]!
        292        Y32++;
               cmp    r3, r6  
             ↑ bne    130     
        304        }    
        305      }      
        306    }        
               
        308    // debug rectangle
        309    if (debug_rectangle){
        144:   ldr    r1, [r5]
               cmp    r1, #0  
             ↓ beq    1a4     
        305      if ((loop & 0x0F) == 0 && debug_rectangle>1){
               ldr    r2, [r4]
               cmp    r1, #1  
               movle  r3, #0  
               movgt  r3, #1  
               ubfx   r2, r2, #0, #4
               cmp    r2, #0  
               movne  r3, #0  
               cmp    r3, #0  
             ↓ bne    7b0     
               movw   r3, #32964      ; 0x80c4
               movt   r3, #2  
               ldr    r5, [r3, #4]
               ldr    r2, [r3, #8]
        309        debug_rect_X = rand()%(w-W_DEBUG_RECT) + W_DEBUG_RECT/2;
        310        debug_rect_Y = rand()%(h-H_DEBUG_RECT) + H_DEBUG_RECT/2;
        311      }      
        312      Draw_Rectangle(&img, debug_rect_X, debug_rect_Y, W_DEBUG_RECT, H_DEBUG_RECT, &red, 1);
        184:   movw   ip, #32936      ; 0x80a8
               movt   ip, #2  
               mov    lr, #1  
               mov    r3, #80 ; 0x50
               ldr    r0, [pc, #1040] ; 142bc <video_buffer_callback+0x5ac>
               mov    r1, r5  
               stm    sp, {r3, ip, lr}
             → bl     Draw_Rectangle
        321  vld1_dup_u8():
               
        10674 __extension__ extern __inline uint8x8_t
        10675 __attribute__  ((__always_inline__, __gnu_inline__, __artificial__))
        10676 vld1_dup_u8 (const uint8_t * __a)
        10677 {           
        10678   return (uint8x8_t)__builtin_neon_vld1_dupv8qi ((const __builtin_neon_qi *) __a);
  0.03  1a4:   ldr    r1, [pc, #1020] ; 142b8 <video_buffer_callback+0x5a8>
        10680 find_chroma_matches_neon():
        47     YUV_T marker = pink; // higlight color
               movw   r2, #32940      ; 0x80ac
               movt   r2, #2  
        50   vdupq_n_u16():
        6756   return (uint16x8_t)__builtin_neon_vdup_nv8hi ((__builtin_neon_hi) __a);
               vmov.i32 q9, #0  ; 0x00000000
        6758 find_chroma_matches_neon():
        74     for (y = sep/2; y <= h - sep/2; y += sep) {
               mov    r3, #1  
        45     int cx=0, cy=0;
               mov    r7, #0  
        47   vcreate_u8():
        6582   return (uint8x8_t)__builtin_neon_vcreatev8qi ((__builtin_neon_di) __a);
               vldr   d28, [pc, #988] ; 142b0 <video_buffer_callback+0x5a0>
        6584 find_chroma_matches_neon():
               mov    r8, r7  
        74     for (y = sep/2; y <= h - sep/2; y += sep) {
               strh   r3, [sp, #42]   ; 0x2a
        46     int h = i->h, w = i->w, half_w = i->half_w;
  0.03         ldmib  r4, {r5, ip}
        48   vdupq_n_u16():
        6756   return (uint16x8_t)__builtin_neon_vdup_nv8hi ((__builtin_neon_hi) __a);
               vorr   q13, q9, q9
               vorr   q8, q9, q9
        6759 vld1_dup_u8():
        10673   return (uint8x8_t)__builtin_neon_vld1_dupv8qi ((const __builtin_neon_qi *) __a);
               vld1.8 {d30[]}, [r1]!
        10675 vdupq_n_u16():
        6756   return (uint16x8_t)__builtin_neon_vdup_nv8hi ((__builtin_neon_hi) __a);
               vorr   q11, q9, q9
        6758 find_chroma_matches_neon():
        47     YUV_T marker = pink; // higlight color
               ldrh   r0, [r2]
        49   vmovl_u8():
        7673   return (uint16x8_t)__builtin_neon_vmovluv8qi ((int8x8_t) __a);
               vmovl.u8 q14, d28
        7675 find_chroma_matches_neon():
        74     for (y = sep/2; y <= h - sep/2; y += sep) {
               cmp    ip, r3  
        46     int h = i->h, w = i->w, half_w = i->half_w;
               str    ip, [sp, #20]
        47     YUV_T marker = pink; // higlight color
               ldrb   r2, [r2, #2]
        46     int h = i->h, w = i->w, half_w = i->half_w;
               ldr    r6, [r4, #12]
        47     YUV_T marker = pink; // higlight color
               strh   r0, [sp, #56]   ; 0x38
        49   vld1_dup_u8():
        10673   return (uint8x8_t)__builtin_neon_vld1_dupv8qi ((const __builtin_neon_qi *) __a);
               vld1.8 {d6[]}, [r1]
        10675 vmovl_u8(): 
        7673   return (uint16x8_t)__builtin_neon_vmovluv8qi ((int8x8_t) __a);
               vmovl.u8 q15, d30
        7675 find_chroma_matches_neon():
               strb   r2, [sp, #58]   ; 0x3a
        48   vmovl_u8():
               vmovl.u8 q3, d6
        7674 find_chroma_matches_neon():
        74     for (y = sep/2; y <= h - sep/2; y += sep) {
             ↓ ble    430     
               movw   r2, #32926      ; 0x809e
               movt   r2, #2  
               movw   fp, #32996      ; 0x80e4
               movt   fp, #2  
               str    r2, [sp, #16]
        75       for (x = 0; x < w; x += 16) {
  0.09  220:   mov    r2, #0  
               cmp    r5, r2  
               strh   r2, [sp, #40]   ; 0x28
             ↓ ble    414     
  0.09         ldrsh  ip, [sp, #42]   ; 0x2a
        81   vdupq_n_u16():
        6756   return (uint16x8_t)__builtin_neon_vdup_nv8hi ((__builtin_neon_hi) __a);
               vmov.i16 q2, #1  ; 0x0001
        6758 vdup_n_u16():
        6659   return (uint16x4_t)__builtin_neon_vdup_nv4hi ((__builtin_neon_hi) __a);
               vmov.i32 d24, #0 ; 0x00000000
               mov    r1, r3  
               mov    r3, r2  
               mov    r2, r1  
        6664 find_chroma_matches_neon():
        81         V_image_8 = vld1_u8(&(i->bV[y/2*half_w + x/2]));
 10.32  248:   add    r1, ip, ip, lsr #31
  9.89         ldrsh  lr, [sp, #40]   ; 0x28
        101          Y_image_u = vld2_u8(&(i->bY[(y-1)*w + x]));
               sub    r0, ip, #1
        80         U_image_8 = vld1_u8(&(i->bU[y/2*half_w + x/2]));
               add    r2, r2, r2, lsr #31
        82   vld1_u8(): 
        10305   return (uint8x8_t)__builtin_neon_vld1v8qi ((const __builtin_neon_qi *) __a);
  3.06         ldr    r9, [r4, #28]
        10307 find_chroma_matches_neon():
        81         V_image_8 = vld1_u8(&(i->bV[y/2*half_w + x/2]));
               asr    r1, r1, #1
        80         U_image_8 = vld1_u8(&(i->bU[y/2*half_w + x/2]));
               asr    r2, r2, #1
        82   vld1_u8(): 
  2.20         ldr    sl, [r4, #24]
        10306 find_chroma_matches_neon():
               add    r3, r3, r3, lsr #31
        101          Y_image_u = vld2_u8(&(i->bY[(y-1)*w + x]));
               mul    r0, r5, r0
        103  vld1_u8(): 
               mla    r1, r6, r1, r9
        10306 vld1q_dup_s16():
               
        10740 __extension__ extern __inline int16x8_t
        10741 __attribute__  ((__always_inline__, __gnu_inline__, __artificial__))
        10742 vld1q_dup_s16 (const int16_t * __a)
        10743 {           
        10744   return (int16x8_t)__builtin_neon_vld1_dupv8hi ((const __builtin_neon_hi *) __a);
  3.49         ldr    r9, [sp, #16]
        10746 vld1_u8():  
        10305   return (uint8x8_t)__builtin_neon_vld1v8qi ((const __builtin_neon_qi *) __a);
               mla    r2, r6, r2, sl
        10307 find_chroma_matches_neon():
        112          vst2_u8(&(i->bY[(y-1)*w + x]), Y_image_u);
               add    sl, r0, lr
        114  vld1q_dup_s16():
        10739   return (int16x8_t)__builtin_neon_vld1_dupv8hi ((const __builtin_neon_hi *) __a);
  9.34         vld1.16 {d2[]-d3[]}, [r9]
        10741 find_chroma_matches_neon():
        81         V_image_8 = vld1_u8(&(i->bV[y/2*half_w + x/2]));
               add    r9, lr, lr, lsr #31
        83   vld1_u8(): 
        10305   return (uint8x8_t)__builtin_neon_vld1v8qi ((const __builtin_neon_qi *) __a);
               add    r3, r2, r3, asr #1
               add    r1, r1, r9, asr #1
        10308 find_chroma_matches_neon():
        99         if (highlight_matches){
  1.71         ldr    r2, [fp]
        101  vld1_u8(): 
 14.75         vld1.8 {d21}, [r3]
  3.12         vld1.8 {d16}, [r1]
        10307 find_chroma_matches_neon():
               cmp    r2, #0  
        100  vmovl_u8():
        7673   return (uint16x8_t)__builtin_neon_vmovluv8qi ((int8x8_t) __a);
               vmovl.u8 q6, d21
               vmovl.u8 q0, d16
        7676 vsubq_s16():
        1922   return __a - __b;
  0.03         vsub.i16 q6, q6, q15
               vsub.i16 q0, q0, q3
        1925 vmulq_s16():
        1160   return __a * __b;
               vmul.i16 q0, q0, q0
        1162 vaddq_s16():
        591    return __a + __b;
               vmla.i16 q0, q6, q6
        593  vcleq_s16():
        2612   return (uint16x8_t)__builtin_neon_vcgev8hi (__b, __a);
  2.42         vcge.s16 q1, q1, q0
        2614 find_chroma_matches_neon():
             ↓ beq    398     
        100  vld1_dup_u8():
        10673   return (uint8x8_t)__builtin_neon_vld1_dupv8qi ((const __builtin_neon_qi *) __a);
               add    r3, sp, #56     ; 0x38
        10675 vld2_u8():  
        11261 __extension__ extern __inline uint8x8x2_t
        11262 __attribute__  ((__always_inline__, __gnu_inline__, __artificial__))
        11263 vld2_u8 (const uint8_t * __a)
        11264 {           
        11265   union { uint8x8x2_t __i; __builtin_neon_ti __o; } __rv;
        11266   __rv.__o = __builtin_neon_vld2v8qi ((const __builtin_neon_qi *) __a);
               ldr    r2, [r4, #20]
        11268 vmovn_u16():
        7568   return (uint8x8_t)__builtin_neon_vmovnv8hi ((int16x8_t) __a);
               vmovn.i16 d17, q1
        7570 vld1_dup_u8():
        10673   return (uint8x8_t)__builtin_neon_vld1_dupv8qi ((const __builtin_neon_qi *) __a);
               add    r1, sp, #58     ; 0x3a
               vld1.8 {d20[]}, [r3]
               add    r3, sp, #57     ; 0x39
               vld1.8 {d25[]}, [r3]
        10678 vld2_u8():  
        11261   __rv.__o = __builtin_neon_vld2v8qi ((const __builtin_neon_qi *) __a);
               add    r3, r2, r0
               mla    ip, r5, ip, r2
        11264 find_chroma_matches_neon():
        112          vst2_u8(&(i->bY[(y-1)*w + x]), Y_image_u);
               add    r2, r2, sl
        114  vld2_u8(): 
               add    r3, r3, lr
        11262 vld1_dup_u8():
        10673   return (uint8x8_t)__builtin_neon_vld1_dupv8qi ((const __builtin_neon_qi *) __a);
               vld1.8 {d14[]}, [r1]
        10675 vld2_u8():  
        11261   __rv.__o = __builtin_neon_vld2v8qi ((const __builtin_neon_qi *) __a);
               vld2.8 {d12-d13}, [r3]
               add    lr, ip, lr
               vld2.8 {d0-d1}, [lr]
        11265 vbsl_u8():  
        9193   return (uint8x8_t)__builtin_neon_vbslv8qi ((int8x8_t) __a, (int8x8_t) __b, (int8x8_t) __c);
               vbit   d21, d25, d17
               vorr   d25, d17, d17
               vbit   d16, d14, d17
        9197 find_chroma_matches_neon():
               vbsl   d25, d20, d12
               vorr   d10, d25, d25
               vorr   d25, d17, d17
               vbsl   d25, d20, d0
               vorr   d8, d25, d25
               vorr   d25, d13, d13
               vbit   d25, d20, d17
               vbsl   d17, d20, d1
               vorr   d11, d25, d25
        121  vst2_u8(): 
        11766 __extension__ extern __inline void
        11767 __attribute__  ((__always_inline__, __gnu_inline__, __artificial__))
        11768 vst2_u8 (uint8_t * __a, uint8x8x2_t __b)
        11769 {           
        11770   union { uint8x8x2_t __i; __builtin_neon_ti __o; } __bu = { __b };
        11771   __builtin_neon_vst2v8qi ((__builtin_neon_qi *) __a, __bu.__o);
               vorr   d9, d17, d17
               vst2.8 {d10-d11}, [r2]
        11774 find_chroma_matches_neon():
        113          vst2_u8(&(i->bY[y*w + x]), Y_image_l);
               ldrsh  r1, [sp, #40]   ; 0x28
               ldrsh  r2, [sp, #42]   ; 0x2a
               ldr    r3, [r4, #20]
               mla    r2, r5, r2, r1
               add    r3, r3, r2
        119  vst2_u8(): 
               vst2.8 {d8-d9}, [r3]
        11767 find_chroma_matches_neon():
        115          vst1_u8(&(i->bU[y/2*half_w + x/2]), U_image_8);
               ldrsh  r3, [sp, #42]   ; 0x2a
        117  vst1_u8(): 
        10883   __builtin_neon_vst1v8qi ((__builtin_neon_qi *) __a, (int8x8_t) __b);
               ldr    r1, [r4, #24]
        10885 find_chroma_matches_neon():
               ldrsh  r2, [sp, #40]   ; 0x28
               add    r3, r3, r3, lsr #31
               asr    r3, r3, #1
               add    r2, r2, r2, lsr #31
        119  vst1_u8(): 
               mla    r3, r6, r3, r1
               add    r3, r3, r2, asr #1
               vst1.8 {d21}, [r3]
        10886 find_chroma_matches_neon():
        116          vst1_u8(&(i->bV[y/2*half_w + x/2]), V_image_8);
               ldrsh  r3, [sp, #42]   ; 0x2a
        118  vst1_u8(): 
               ldr    r1, [r4, #28]
        10884 find_chroma_matches_neon():
               ldrsh  r2, [sp, #40]   ; 0x28
               add    r3, r3, r3, lsr #31
               asr    r3, r3, #1
               add    r2, r2, r2, lsr #31
        120  vst1_u8(): 
               mla    r3, r6, r3, r1
               add    r3, r3, r2, asr #1
               vst1.8 {d16}, [r3]
               ldrsh  ip, [sp, #42]   ; 0x2a
        10887 vld1q_dup_u16():
        10777   return (uint16x8_t)__builtin_neon_vld1_dupv8hi ((const __builtin_neon_hi *) __a);
  0.09  398:   add    r3, sp, #40     ; 0x28
        10779 vandq_u16():
               
        13830 __extension__ extern __inline uint16x8_t
        13831 __attribute__  ((__always_inline__, __gnu_inline__, __artificial__))
        13832 vandq_u16 (uint16x8_t __a, uint16x8_t __b)
        13833 {           
        13834   return __a & __b;
               vand   q1, q2, q1
        13836 vld1q_dup_u16():
        10777   return (uint16x8_t)__builtin_neon_vld1_dupv8hi ((const __builtin_neon_hi *) __a);
               mov    r2, ip  
  2.36         vld1.16 {d20[]-d21[]}, [r3]
               add    r3, sp, #42     ; 0x2a
  5.05         vld1.16 {d16[]-d17[]}, [r3]
        10782 vaddq_u16():
        630    return __a + __b;
               vadd.i16 q11, q11, q1
        632  find_chroma_matches_neon():
        75       for (x = 0; x < w; x += 16) {
  3.73         ldrh   r3, [sp, #40]   ; 0x28
        77   vaddq_u16():
               vadd.i16 q10, q10, q14
        631  find_chroma_matches_neon():
               add    r3, r3, #16
               sxth   r3, r3  
        77   vmlaq_u16():
        1481   return (uint16x8_t)__builtin_neon_vmlav8hi ((int16x8_t) __a, (int16x8_t) __b, (int16x8_t) __c);
  1.25         vmla.i16 q13, q1, q8
        1483 find_chroma_matches_neon():
               cmp    r5, r3  
 10.04         strh   r3, [sp, #40]   ; 0x28
        77   vmlaq_u16():
               vmla.i16 q9, q1, q10
               vorr   q8, q13, q13
               vorr   q10, q9, q9
        1484 vdupq_n_u16():
        6756   return (uint16x8_t)__builtin_neon_vdup_nv8hi ((__builtin_neon_hi) __a);
  1.93         vmov.i32 q9, #0  ; 0x00000000
        6758 vpadd_u16():
        3547   return (uint16x4_t)__builtin_neon_vpaddv4hi ((int16x4_t) __a, (int16x4_t) __b);
               vpadd.i16 d16, d17, d16
               vpadd.i16 d17, d21, d20
        3550 vdupq_n_u16():
        6756   return (uint16x8_t)__builtin_neon_vdup_nv8hi ((__builtin_neon_hi) __a);
               vorr   q13, q9, q9
        6758 vpadd_u16():
        3547   return (uint16x4_t)__builtin_neon_vpaddv4hi ((int16x4_t) __a, (int16x4_t) __b);
 11.29         vpadd.i16 d16, d16, d24
               vpadd.i16 d17, d17, d24
        3550 vpaddl_u16():
        3589   return (uint32x2_t)__builtin_neon_vpaddluv4hi ((int16x4_t) __a);
               vpaddl.u16 d16, d16
               vpaddl.u16 d17, d17
        3592 vget_lane_u32():
        6190   return (uint32_t)__builtin_neon_vget_laneuv2si ((int32x2_t) __a, __b);
  2.63         vmov.32 r0, d16[0]
               vmov.32 r1, d17[0]
        6193 find_chroma_matches_neon():
        152        cy += vget_lane_u32(sum, 0);
               add    r7, r0, r7
        142        cx += vget_lane_u32(sum, 0);
               add    r8, r1, r8
        75       for (x = 0; x < w; x += 16) {
             ↑ bgt    248     
  0.64         mov    r3, ip  
        74     for (y = sep/2; y <= h - sep/2; y += sep) {
  0.21  414:   ldr    r2, [sp, #20]
               add    r3, r3, #2
               sxth   r3, r3  
               strh   r3, [sp, #42]   ; 0x2a
               cmp    r2, r3  
             ↑ bgt    220     
               vorr   q8, q11, q11
        82   vpadd_u16():
        3547   return (uint16x4_t)__builtin_neon_vpaddv4hi ((int16x4_t) __a, (int16x4_t) __b);
        430:   vpadd.i16 d16, d17, d16
        3549 vdup_n_u16():
        6659   return (uint16x4_t)__builtin_neon_vdup_nv4hi ((__builtin_neon_hi) __a);
               vmov.i32 d17, #0 ; 0x00000000
        6661 vpadd_u16():
        3547   return (uint16x4_t)__builtin_neon_vpaddv4hi ((int16x4_t) __a, (int16x4_t) __b);
               vpadd.i16 d16, d16, d17
        3549 vpaddl_u16():
        3589   return (uint32x2_t)__builtin_neon_vpaddluv4hi ((int16x4_t) __a);
               vpaddl.u16 d16, d16
        3591 vget_lane_u32():
        6190   return (uint32_t)__builtin_neon_vget_laneuv2si ((int32x2_t) __a, __b);
               vmov.32 r5, d16[0]
        6192 find_chroma_matches_neon():
        173    if (matches > 0) {
               cmp    r5, #0  
             ↓ ble    658     
        174      cx /= matches;
               sdiv   r8, r8, r5
        176  video_buffer_callback():
        317    // find area matching target color
        318    int centroid_x, centroid_y, num_matches, offsetX, offsetY;
        319    num_matches = find_chroma_matches_neon(&img, &target, &centroid_x, &centroid_y, chroma_subsample_sep);
               
        321    // draw center circles
        322    draw_overlay_info(&img);
               ldr    r0, [pc, #340]  ; 142bc <video_buffer_callback+0x5ac>
        324  find_chroma_matches_neon():
        175      cy /= matches;
               sdiv   r7, r7, r5
        177  video_buffer_callback():
        317    draw_overlay_info(&img);
             → bl     draw_overlay_info
               
        323    // image stabilizaton
        324    if (num_matches > 0) {
        325      // Show centroid
        326      Draw_Circle(&img, centroid_x, centroid_y, 10, &white, 1);
               mov    r2, #1  
               movw   r3, #32956      ; 0x80bc
               movt   r3, #2  
               ldr    r0, [pc, #316]  ; 142bc <video_buffer_callback+0x5ac>
               mov    r1, r8  
               str    r3, [sp]
               mov    r3, #10 
               str    r2, [sp, #4]
               mov    r2, r7  
             → bl     Draw_Circle
        325      offsetX = img.half_w - centroid_x;
        326      offsetY = img.half_h - centroid_y;
        327      if (show_data > 1) {
               ldr    r3, [sp, #24]
        323      offsetX = img.half_w - centroid_x;
               ldr    r6, [r4, #12]
        324      offsetY = img.half_h - centroid_y;
               ldr    r9, [r4, #16]
        325      if (show_data > 1) {
               ldr    r3, [r3]
        323      offsetX = img.half_w - centroid_x;
               sub    r6, r6, r8
        324      offsetY = img.half_h - centroid_y;
               sub    r9, r9, r7
        325      if (show_data > 1) {
               cmp    r3, #1  
             ↓ bgt    6c4     
        331        printf("Match centroid at (%d, %d) for %d samples\n",
        332                centroid_x, centroid_y, num_matches);
        333        printf("Offset = %d, %d\n", offsetX, offsetY);
        334      }      
        335      // Correct image position
        336      if (imstab_digital) {
        4a4:   movw   r3, #32920      ; 0x8098
               movt   r3, #2  
               ldr    r3, [r3]
               cmp    r3, #0  
             ↓ bne    778     
        338        YUV_Image_Copy(&img2, &img);
        339        //        target.y = 128; // overwrite
        340        YUV_Image_Fill(&img, &target);
        341        YUV_Translate_Image(&img, &img2, offsetX, offsetY, 0);
        342      }      
        343      if (imstab_servo) {
        4b8:   movw   r3, #32992      ; 0x80e0
               movt   r3, #2  
               ldr    r3, [r3]
               cmp    r3, #0  
             ↓ bne    768     
        344        Update_Servo(offsetX, offsetY);
        345      }      
        346    }        
               
        348    // Send modified image in new buffer to preview component
        349    if (mmal_port_send_buffer(preview_input_port, buffer) != MMAL_SUCCESS) {
        4cc:   movw   r3, #33012      ; 0x80f4
               movt   r3, #2  
               ldr    r1, [sp, #32]
               ldr    r0, [r3]
             → bl     mmal_port_send_buffer@plt
               cmp    r0, #0  
             ↓ bne    6b4     
        348      printf("ERROR: Unable to send buffer \n");
        349    }        
               
        351    mmal_buffer_header_release(buffer);
        4e8:   ldr    r0, [sp, #32]
             → bl     mmal_buffer_header_release@plt
               
        352    // and send one back to the port (if still open)
        353    if (port->is_enabled) {
               ldr    r3, [sp, #28]
  0.03         ldr    r3, [r3, #16]
               cmp    r3, #0  
             ↓ bne    680     
        361      if (!new_buffer || status != MMAL_SUCCESS)
        362        printf("Unable to return a buffer to the video port\n");
        363    }        
               
        365    // get precessing time
        366    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &t2);
        500:   add    r1, sp, #56     ; 0x38
               mov    r0, #2  
             → bl     clock_gettime@plt
        362    long t = t2.tv_nsec - t1.tv_nsec;
               ldr    r3, [sp, #52]   ; 0x34
               ldr    r6, [sp, #60]   ; 0x3c
        363    if (t<0) 
               subs   r6, r6, r3
             ↓ bpl    528     
        364      t += 1000000000;
               add    r6, r6, #998244352      ; 0x3b800000
               add    r6, r6, #1753088        ; 0x1ac000
               add    r6, r6, #2560   ; 0xa00
        365    if (loop > 1) {
        528:   ldr    r3, [r4]
               ldr    r2, [sp, #24]
               cmp    r3, #1  
               ldr    r1, [r2]
             ↓ ble    560     
        366      long period = (tcf.tv_nsec - tpf.tv_nsec);
               ldr    r2, [r4, #64]   ; 0x40
               ldr    r3, [sp, #68]   ; 0x44
        367      if (period < 0)
               subs   r3, r3, r2
             ↓ bpl    558     
        368        period += 1000000000;
               add    r3, r3, #998244352      ; 0x3b800000
               add    r3, r3, #1753088        ; 0x1ac000
               add    r3, r3, #2560   ; 0xa00
        369      if (show_data > 2)
        558:   cmp    r1, #2  
             ↓ bgt    72c     
        372        printf("Frame processing time: %.3f of %.3f ms\n", t/1000000.0, period/1000000.0);
        373    }        
        374    t_sum_ms += t/1000000;
        560:   movw   r3, #56963      ; 0xde83
               movt   r3, #17179      ; 0x431b
               asr    r2, r6, #31
               
        376    // print log
        377    if (show_data > 0) {
               cmp    r1, #0  
        372    t_sum_ms += t/1000000;
               vldr   d16, [r4, #72]  ; 0x48
               smull  r3, r1, r3, r6
               rsb    r3, r2, r1, asr #18
               vmov   s15, r3 
               vcvt.f64.s32 d17, s15
               vadd.f64 d17, d17, d16
               vstr   d17, [r4, #72]  ; 0x48
        375    if (show_data > 0) {
             ↓ ble    5b0     
        376      if (loop) { // change display frequency here!
               ldr    r1, [r4]
               cmp    r1, #0  
             ↓ bne    6f4     
             ↓ b      5b0     
               .word  0x06040200
               .word  0x0e0c0a08
               .word  0x000280c5
               .word  0x000280fc
        380        printf("%5d Frame processing times:  Cur. %.6f ms  |  Avg. %.6f ms  |  matches: %5d\n", loop, t/1000000.0, ((double) t_sum_ms)/loop, num_matches);
        381      }      
        382    }        
        383    tpf = tcf;
        5b0:   ldrd   r2, [sp, #64]   ; 0x40
               strd   r2, [r4, #60]   ; 0x3c
        381  }          
               add    sp, sp, #76     ; 0x4c
  0.03         vpop   {d8-d14}
               ldrd   r4, [sp]
               ldrd   r6, [sp, #8]
               ldrd   r8, [sp, #16]
               ldrd   sl, [sp, #24]
               add    sp, sp, #32
               pop    {pc}            ; (ldr pc, [sp], #4)
        294    } else if (invert_rect) {
        5d8:   movw   r3, #33004      ; 0x80ec
               movt   r3, #2  
               ldr    r3, [r3]
               cmp    r3, #0  
             ↑ beq    144     
               add    r0, r6, #204800 ; 0x32000
               add    r1, r6, #205824 ; 0x32400
               add    r6, r6, #716800 ; 0xaf000
               add    r0, r0, #240    ; 0xf0
               add    r1, r1, #16
               add    r6, r6, #1040   ; 0x410
        238  void video_buffer_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer) {
        604:   mov    r2, r0  
               mov    r3, r0  
        298          Y[y*w + x] ^= 0xff;
        60c:   vld1.8 {d16-d17}, [r2]!
               vmvn   q8, q8  
               vst1.8 {d16-d17}, [r3]!
               cmp    r3, r1  
             ↑ bne    60c     
               add    r1, r1, #1280   ; 0x500
               add    r0, r0, #1280   ; 0x500
        296      for (y = h/2 - H_INVERT_RECT/2; y < h/2 + H_INVERT_RECT/2; y++) {
               cmp    r1, r6  
             ↑ bne    604     
             ↑ b      144     
        279        target = red;
        634:   movw   r3, #32936      ; 0x80a8
               movt   r3, #2  
               ldrh   r0, [r3]
               movw   r1, #32964      ; 0x80c4
               movt   r1, #2  
               ldrb   r3, [r3, #2]
               strh   r0, [r1]
               strb   r3, [r1, #2]
             ↑ b      f8      
        317    draw_overlay_info(&img);
        658:   ldr    r0, [pc, #-180] ; 142bc <video_buffer_callback+0x5ac>
             → bl     draw_overlay_info
        320    if (num_matches > 0) {
             ↑ b      4cc     
        276      printf("\nCenter pixel: (%d, %d, %d)\n", center_color.y, center_color.u, center_color.v);
        664:   movw   r0, #31012      ; 0x7924
               movt   r0, #1  
               ldrb   r3, [sp, #46]   ; 0x2e
               ldrb   r2, [sp, #45]   ; 0x2d
               ldrb   r1, [sp, #44]   ; 0x2c
             → bl     printf@plt
             ↑ b      b8      
        353      new_buffer = mmal_queue_get(pool->queue);
        680:   ldr    r3, [sp, #36]   ; 0x24
               ldr    r0, [r3]
             → bl     mmal_queue_get@plt
        354      if (new_buffer)
               subs   r1, r0, #0
             ↓ beq    6a4     
        355        status = mmal_port_send_buffer(port, new_buffer);
               ldr    r0, [sp, #28]
             → bl     mmal_port_send_buffer@plt
        356      if (!new_buffer || status != MMAL_SUCCESS)
               cmp    r0, #0  
             ↑ beq    500     
        357        printf("Unable to return a buffer to the video port\n");
        6a4:   movw   r0, #31180      ; 0x79cc
               movt   r0, #1  
             → bl     puts@plt
             ↑ b      500     
        345      printf("ERROR: Unable to send buffer \n");
        6b4:   movw   r0, #31148      ; 0x79ac
               movt   r0, #1  
             → bl     puts@plt
             ↑ b      4e8     
        326        printf("Match centroid at (%d, %d) for %d samples\n",
        6c4:   mov    r2, r7  
               mov    r1, r8  
               mov    r3, r5  
               movw   r0, #31084      ; 0x796c
               movt   r0, #1  
             → bl     printf@plt
        328        printf("Offset = %d, %d\n", offsetX, offsetY);
               mov    r2, r9  
               mov    r1, r6  
               movw   r0, #31128      ; 0x7998
               movt   r0, #1  
             → bl     printf@plt
             ↑ b      4a4     
        377        printf("%5d Frame processing times:  Cur. %.6f ms  |  Avg. %.6f ms  |  matches: %5d\n", loop, t/1000000.0, ((double) t_sum_ms)/loop, num_matches);
        6f4:   vmov   s15, r1 
               movw   r0, #31264      ; 0x7a20
               movt   r0, #1  
               vldr   d19, [pc, #264] ; 14520 <video_buffer_callback+0x810>
               str    r5, [sp, #8]
               vcvt.f64.s32 d20, s15
               vmov   s15, r6 
               vdiv.f64 d18, d17, d20
               vcvt.f64.s32 d16, s15
               vmul.f64 d16, d16, d19
               vmov   r2, r3, d16
               vstr   d18, [sp]
             → bl     printf@plt
             ↑ b      5b0     
        370        printf("Frame processing time: %.3f of %.3f ms\n", t/1000000.0, period/1000000.0);
        72c:   vmov   s15, r3 
               movw   r0, #31224      ; 0x79f8
               movt   r0, #1  
               vldr   d18, [pc, #208] ; 14520 <video_buffer_callback+0x810>
               vcvt.f64.s32 d16, s15
               vmov   s15, r6 
               vmul.f64 d16, d16, d18
               vcvt.f64.s32 d17, s15
               vstr   d16, [sp]
               vmul.f64 d17, d17, d18
               vmov   r2, r3, d17
             → bl     printf@plt
               ldr    r3, [sp, #24]
               ldr    r1, [r3]
             ↑ b      560     
        339        Update_Servo(offsetX, offsetY);
        768:   mov    r1, r9  
               mov    r0, r6  
             → bl     Update_Servo
             ↑ b      4cc     
        333        YUV_Image_Copy(&img2, &img);
  0.03  778:   ldr    r1, [pc, #156]  ; 1452c <video_buffer_callback+0x81c>
               add    r0, r1, #28
             → bl     YUV_Image_Copy
        335        YUV_Image_Fill(&img, &target);
  0.03         ldr    r0, [pc, #144]  ; 1452c <video_buffer_callback+0x81c>
               movw   r1, #32964      ; 0x80c4
               movt   r1, #2  
             → bl     YUV_Image_Fill
        336        YUV_Translate_Image(&img, &img2, offsetX, offsetY, 0);
               ldr    r1, [pc, #132]  ; 14530 <video_buffer_callback+0x820>
               mov    r3, r9  
               mov    r2, r6  
               vldr   s0, [pc, #112]  ; 14528 <video_buffer_callback+0x818>
               sub    r0, r1, #28
             → bl     YUV_Translate_Image
             ↑ b      4b8     
        306        debug_rect_X = rand()%(w-W_DEBUG_RECT) + W_DEBUG_RECT/2;
        7b0: → bl     rand@plt
               movw   r2, #33205      ; 0x81b5
               movt   r2, #6990       ; 0x1b4e
               asr    r3, r0, #31
               mov    r5, #1200       ; 0x4b0
               movw   r6, #32964      ; 0x80c4
               movt   r6, #2  
               smull  r1, r2, r2, r0
               rsb    r3, r3, r2, asr #7
               mls    r3, r5, r3, r0
               add    r5, r3, #40     ; 0x28
               str    r5, [r6, #4]
        307        debug_rect_Y = rand()%(h-H_DEBUG_RECT) + H_DEBUG_RECT/2;
             → bl     rand@plt
               movw   r3, #26215      ; 0x6667
               movt   r3, #26214      ; 0x6666
               asr    r2, r0, #31
               smull  r1, r3, r3, r0
               rsb    r2, r2, r3, asr #8
               add    r2, r2, r2, lsl #2
               sub    r2, r0, r2, lsl #7
               add    r2, r2, #40     ; 0x28
               str    r2, [r6, #8]
             ↑ b      184     
               nop    {0}     
               .word  0xa0b5ed8d
               .word  0x3eb0c6f7
               .word  0x00000000
               .word  0x000280fc
               .word  0x00028118
